<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Heart Gesture Detector — Live Camera</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#ef476f;--muted:#9ca3af}
    body{margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071022 0%, #07102a 100%);font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    .app{width:900px;max-width:96%;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:18px;box-shadow:0 8px 30px rgba(2,6,23,0.6);color:#e6eef8}
    header{display:flex;align-items:center;gap:12px;margin-bottom:8px}
    header h1{font-size:18px;margin:0}
    .controls{display:flex;gap:8px;margin-left:auto}
    button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:white;cursor:pointer;font-weight:600}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
    .stage{display:grid;grid-template-columns:640px 1fr;gap:12px}
    .video-wrap{position:relative;background:#000;border-radius:8px;overflow:hidden;display:flex;align-items:center;justify-content:center}
    video{width:640px;height:480px;object-fit:cover;transform:scaleX(-1)}
    canvas{position:absolute;left:0;top:0;transform:scaleX(-1)}
    .status{padding:12px;background:rgba(255,255,255,0.02);border-radius:8px;min-height:480px}
    .big-msg{font-size:48px;font-weight:800;color:var(--accent);display:flex;align-items:center;gap:10px;justify-content:center;height:240px}
    .info{color:var(--muted);font-size:13px}
    .indicator{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.4);padding:6px 10px;border-radius:8px;font-weight:600}
    .on{color:#4ade80}
    .off{color:#f97316}
    footer{margin-top:12px;color:var(--muted);font-size:13px}
    @media (max-width:900px){.stage{grid-template-columns:1fr}video,canvas{width:100%;height:auto}} 
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Heart Gesture Detector</h1>
      <div class="controls">
        <button id="startBtn">Start Camera</button>
        <button id="stopBtn" class="secondary">Stop</button>
      </div>
    </header>

    <div class="stage">
      <div class="video-wrap">
        <div class="indicator">Camera: <span id="camState" class="off">off</span></div>
        <video id="video" autoplay playsinline></video>
        <canvas id="overlay" width="640" height="480"></canvas>
      </div>

      <div class="status">
        <div class="big-msg" id="bigMsg">Make a heart with both hands</div>
        <p class="info">How it works: The page uses MediaPipe Hands to detect up to two hands. If the index fingertips and thumb-tips of both hands come close together (forming the classic two-hands heart shape), the app shows "Love it".</p>
        <ul class="info">
          <li>Use in a well-lit space and face the camera.</li>
          <li>Bring both hands into frame so the model sees two hands.</li>
          <li>If detection is unreliable, move slowly or adjust lighting.</li>
        </ul>
      </div>
    </div>
    <footer>Built with MediaPipe Hands • No uploads — runs in your browser.</footer>
  </div>

  <!-- MediaPipe libraries from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
    const videoElement = document.getElementById('video');
    const canvasElement = document.getElementById('overlay');
    const canvasCtx = canvasElement.getContext('2d');
    const camState = document.getElementById('camState');
    const bigMsg = document.getElementById('bigMsg');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');

    let camera = null;
    let lastHeartTime = 0;

    function setCamState(on){
      camState.textContent = on ? 'on' : 'off';
      camState.className = on ? 'on' : 'off';
    }

    // Utility: Euclidean distance for normalized coordinates
    function ndist(a,b){
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy + ( (a.z||0)-(b.z||0) )**2);
    }

    // Heart detection logic: expects exactly two hands
    function isHeartGesture(multiHandLandmarks){
      if(!multiHandLandmarks || multiHandLandmarks.length < 2) return false;
      const A = multiHandLandmarks[0];
      const B = multiHandLandmarks[1];
      // Indices: 4=thumb_tip, 8=index_tip (MediaPipe indexing)
      const a_thumb = A[4];
      const a_index = A[8];
      const b_thumb = B[4];
      const b_index = B[8];

      // Distances between opposite tips (index-index and thumb-thumb)
      const dIndex = ndist(a_index, b_index);
      const dThumb = ndist(a_thumb, b_thumb);

      // Also check distance between index and thumb across hands to ensure 'V' overlap
      const cross1 = ndist(a_index, b_thumb);
      const cross2 = ndist(b_index, a_thumb);

      // thresholds tuned for normalized coordinates (0-1). You can tweak these.
      const closeThreshold = 0.12; // how close tips should be
      const crossThreshold = 0.22;  // cross distances should not be huge

      // Basic rule: both index tips and both thumb tips are near each other
      const nearTips = dIndex < closeThreshold && dThumb < closeThreshold;
      const crossOK = (cross1 < crossThreshold && cross2 < crossThreshold);

      return nearTips && crossOK;
    }

    // Visual feedback and drawing
    function drawHands(results){
      canvasCtx.save();
      canvasCtx.clearRect(0,0,canvasElement.width,canvasElement.height);

      if(results.multiHandLandmarks && results.multiHandLandmarks.length){
        for(let i=0;i<results.multiHandLandmarks.length;i++){
          const landmarks = results.multiHandLandmarks[i];
          // draw joints & connections
          window.drawConnectors(canvasCtx, landmarks, window.HAND_CONNECTIONS, {lineWidth:2});
          window.drawLandmarks(canvasCtx, landmarks, {lineWidth:2});
        }
      }

      canvasCtx.restore();
    }

    // Called on each inference
    function onResults(results){
      drawHands(results);

      const hands = results.multiHandLandmarks;
      if(isHeartGesture(hands)){
        // debounce so message isn't flickery
        const now = Date.now();
        lastHeartTime = now;
        bigMsg.textContent = 'Love it ❤️';
        bigMsg.style.color = 'var(--accent)';
      } else {
        // if recently detected keep it for a short time for stability
        if(Date.now() - lastHeartTime < 800) {
          // keep showing
        } else {
          bigMsg.textContent = 'Make a heart with both hands';
          bigMsg.style.color = '';
        }
      }
    }

    // Create the MediaPipe Hands solution
    const hands = new Hands({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });
    hands.onResults(onResults);

    async function startCamera(){
      if(camera) return;
      setCamState(false);
      try{
        camera = new Camera(videoElement, {
          onFrame: async () => { await hands.send({image: videoElement}); },
          width: 640,
          height: 480
        });
        await camera.start();
        setCamState(true);
      }catch(err){
        alert('Could not access camera. Check permissions. ' + err.message);
        console.error(err);
      }
    }

    function stopCamera(){
      if(camera){
        camera.stop();
        camera=null;
      }
      setCamState(false);
    }

    // Buttons
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);

    // Auto-start on page load if user allows
    window.addEventListener('load', ()=>{
      // nothing automatic — wait for user to press Start for privacy
    });

    // Resize canvas when video size changes
    function resizeCanvas(){
      canvasElement.width = videoElement.videoWidth || 640;
      canvasElement.height = videoElement.videoHeight || 480;
    }
    videoElement.addEventListener('loadedmetadata', resizeCanvas);
    videoElement.addEventListener('resize', resizeCanvas);
  </script>
</body>
</html>